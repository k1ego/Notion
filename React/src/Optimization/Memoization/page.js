// Мемоизация компонентов позволяет 
// остановить цепочки перерендеров
// бывают ситуации, когда перерендеривается родитель
// и все его дочерние перерендериваются, то не всегда эти
// дочерние нужно перерендеривать - для них ничего не изменилось 
// как понять что для них ничего не поменялось? - по пропсам
// мемоизируем дочерние компоненты и при перерендере родителя
// мемоизация смотрит изменились ли пропсы? - если изменились,
// то перерендеривается и этот компонент 
// в идеале memo нужно использовать так, чтобы прерывать цепочки перерендеров
// То есть если один из дочерних на каком либо уровне говорит, что 
// перерендер не нужен, то и остальные дочерние не перерендерятся, которые ниже уровнем
// мемоизацию использовать - когда у нас адекватные пропсы, если их вообще нет - это замечательно
// или если много проспсов и они часто меняются - смыса нет использовать мемо
// если компонент с мемо, то в этот компонент в пропсы стрелочной функции как например на кнопке
// просто так закидывать не нужно их обязательно оборачивать в useCallback
// потому что еслиссылка на каждом рендеребудет создаваться, то мемоизация будет 
// тратить ресурсы, но не приносить никакого смысла 

import React, { useState } from 'react';
import { SlowComponent } from './SlowComponent';

export default function Memoization() {
	const [count, setCount] = useState(0);

	return (
		<div>
			<button onClick={() => setCount(count => count + 1)}>{count}</button>
			<MemoizedSlowComponent />
		</div>
	);
}

// кстати это hoc
const MemoizedSlowComponent = React.memo(SlowComponent)
